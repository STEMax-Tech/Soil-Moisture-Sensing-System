{"files":{"pxt.json":"{\n    \"name\": \"MakerEdu_Hardware\",\n    \"version\": \"0.0.2\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"microphone\": \"*\",\n        \"bluetooth\": \"*\",\n        \"devices\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"pxt-ds18b20.cpp\",\n        \"pxt-ds3231.cpp\",\n        \"shims.d.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"5.0.12\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"yotta\": {\n        \"config\": {\n            \"microbit-dal\": {\n                \"bluetooth\": {\n                    \"open\": 1,\n                    \"whitelist\": 0,\n                    \"security_level\": null\n                }\n            }\n        }\n    }\n}\n","main.ts":"/* ------------------------------------------------------------------------- */\n/*                                   DRIVER                                  */\n/* ------------------------------------------------------------------------- */\n\n//! pxt-l9110\n\n//% color=\"#FF9E9E\" weight=8 icon=\"\\uf018\" block=\"Driver\"\nnamespace l9110 {\n    export enum Motor {\n        //% block=\"A\"\n        MotorA = 0,\n        //% block=\"B\"\n        MotorB = 1\n    }\n\n    export enum Rotate {\n        //% block=\"forward\"\n        Forward = 0,\n        //% block=\"backward\"\n        Backward = 1\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * At first time use\n     * Must stop all motors before use\n     * Only need one time \n     */\n    let _initOneTime = false;\n\n    /* --------------------------------------------------------------------- */\n\n    export function initDriver() {\n        if (!_initOneTime) {\n            pins.digitalWritePin(DigitalPin.P13, 0); // Channel B of Motor_A\n            pins.digitalWritePin(DigitalPin.P14, 0); // Channel A of Motor_A\n            pins.digitalWritePin(DigitalPin.P15, 0); // Channel B of Motor_B\n            pins.digitalWritePin(DigitalPin.P16, 0); // Channel A of Motor_B\n\n            _initOneTime = true;\n        }\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * Control DC motor with parameters: speed & direction of rotation\n     * @param motor choose motor A or motor B\n     * @param rotate set the motor rotation direction\n     * @param speed set the rotational speed of the motor\n     */\n    //% block=\"Driver \\\\| Control motor $motor rotation $rotate with speed $speed \\\\%\"\n    //% motor.defl=Motor.MotorA\n    //% rotate.defl=Rotate.Forward\n    //% speed.defl=50 speed.min=0 speed.max=100\n    //% inlineInputMode=inline\n    //% weight=2\n    export function controlMotor(motor: Motor, rotate: Rotate, speed: number) {\n        /* The first initialize, make Driver stop before do anything */\n        initDriver();\n\n        /* Convert (%) value to PWM value */\n        speed = pins.map(speed, 0, 100, 0, 1023);\n\n        switch (motor) {\n            case Motor.MotorA: {\n                if (rotate) { // Backward\n                    pins.digitalWritePin(DigitalPin.P14, 0);   // A+\n                    pins.analogWritePin(AnalogPin.P13, speed); // B-\n                }\n                else { // Forward\n                    pins.analogWritePin(AnalogPin.P14, speed); // A+\n                    pins.digitalWritePin(DigitalPin.P13, 0);   // B-\n                }\n                break;\n            }\n            case Motor.MotorB: {\n                if (rotate) { // Backward\n                    pins.digitalWritePin(DigitalPin.P16, 0);   // A+\n                    pins.analogWritePin(AnalogPin.P15, speed); // B-\n                }\n                else { // Forward\n                    pins.analogWritePin(AnalogPin.P16, speed); // A+\n                    pins.digitalWritePin(DigitalPin.P15, 0);   // B-\n                }\n                break;\n            }\n        }\n    }\n\n    /**\n     * Make the engine stop\n     * @param motor choose motor A or motor B\n     */\n    //% block=\"Driver \\\\| Stop motor $motor\"\n    //% motor.defl=Motor.MotorA\n    //% inlineInputMode=inline\n    //% weight=1\n    export function pauseMotor(motor: Motor) {\n        /* The first initialize, make Driver stop before do anything */\n        initDriver();\n\n        switch (motor) {\n            case Motor.MotorA: {\n                pins.digitalWritePin(DigitalPin.P14, 0); // A+\n                pins.digitalWritePin(DigitalPin.P13, 0); // B-\n                break;\n            }\n            case Motor.MotorB: {\n                pins.digitalWritePin(DigitalPin.P16, 0); // A+\n                pins.digitalWritePin(DigitalPin.P15, 0); // B-\n                break;\n            }\n        }\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/*                             SENSOR ULTRASONIC                             */\n/* ------------------------------------------------------------------------- */\n\n//! pxt-ultraSonic\n\n//% color=\"#41C0B5\" weight=7 icon=\"\\uf161\" block=\"S01\"\nnamespace ultraSonic {\n    export enum PingUnit {\n        //% block=\"(cm)\"\n        Centimeters = 0,\n        //% block=\"(inch)\"\n        Inches = 1\n    }\n\n    export enum PinKit {\n        //% block=\"(P0+P1)\"\n        Port1 = 0,\n        //% block=\"(P2+P8)\"\n        Port2 = 1\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    const SAMPLE_NUMBER = 5;\n\n    /* --------------------------------------------------------------------- */\n\n    export function getDuration(echo: DigitalPin, trig: DigitalPin): number {\n        /* Send pulse */\n        pins.setPull(trig, PinPullMode.PullNone);\n        pins.digitalWritePin(trig, 0);  // Clears the TriggerPin condition\n        control.waitMicros(2);\n        pins.digitalWritePin(trig, 1);  // Sets the TriggerPin HIGH (ACTIVE) for 10us\n        control.waitMicros(10);\n        pins.digitalWritePin(trig, 0);\n\n        /**\n         * Read pulse (https://makecode.microbit.org/reference/pins/pulse-in)\n         * If no pulse is received, the duration returned is 0\n         * \n         * maxCmDistance * 2\n         * ----------------- = maxCmDistance * 57.7817583\n         *     0.034613\n         * \n         * Maximum distance in centimeters (default is 300 cm)\n         * = 300 * 57.7817583\n         * = 17,334.52749\n         * ~ 17,335\n         */\n        return pins.pulseIn(echo, PulseValue.High, 17335);\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * Measure the distance by sending a sound wave and get duration the time response (in microseconds)\n     * @param unit desired conversion unit\n     * @param port select 4-pin port\n     */\n    //% block=\"S01 UltraSonic Distance \\\\| Read distance $unit from port $port\"\n    //% unit.defl=PingUnit.Centimeters\n    //% port.defl=PinKit.Port1 port.fieldEditor=\"gridpicker\" port.fieldOptions.columns=2\n    //% inlineInputMode=inline\n    export function readDistance(unit: PingUnit, port: PinKit): number {\n        /* Port? */\n        let echo, trig;\n        switch (port) {\n            case PinKit.Port1: echo = DigitalPin.P1; trig = DigitalPin.P0; break;\n            case PinKit.Port2: echo = DigitalPin.P8; trig = DigitalPin.P2; break;\n        }\n\n        /* Perform 5 samplings, take the average value */\n        let duration = 0;\n        for (let i = 0; i < SAMPLE_NUMBER; i++) {\n            duration = duration + getDuration(echo, trig);\n            basic.pause(18); //! ~ 17,335\n        }\n        duration = duration / SAMPLE_NUMBER;\n\n        /**\n         * Return the distance (cm)\n         * \n         *            0.034613                          duration\n         * duration * -------- = duration * 0.0173065 ~ --------\n         *               2                                57.78\n         * \n         * Return the distance (inches)\n         *            0.034613                                   duration\n         * duration * -------- * 0.3937 = duration * 0.0068135 ~ --------\n         *               2                                        146.77\n         */\n        if (duration == 0)\n            return 0;\n        switch (unit) {\n            case PingUnit.Centimeters: return Math.round(duration * 0.0173065);\n            case PingUnit.Inches: return Math.round(duration * 0.0068135);\n        }\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/*                                SENSOR DHT11                               */\n/* ------------------------------------------------------------------------- */\n\n//! pxt-dht11\n\n//% color=\"#41C0B5\" weight=6 icon=\"\\uf043\" block=\"S14\"\nnamespace dht11 {\n    export enum TemperatureType {\n        //% block=\"¬∞C\"\n        Celsius = 0,\n        //% block=\"¬∞F\"\n        Fahrenheit = 1\n    }\n\n    export enum PinKit {\n        //% block=\"P0\"\n        P0 = 0,\n        //% block=\"P1\"\n        P1 = 1,\n        //% block=\"P2\"\n        P2 = 2,\n        //% block=\"P13\"\n        P13 = 3,\n        //% block=\"P14\"\n        P14 = 4,\n        //% block=\"P15\"\n        P15 = 5\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /* Store values for each sensor using separate Pin */\n    const _temperature: number[] = [0, 0, 0, 0, 0, 0];\n    const _humidity: number[] = [0, 0, 0, 0, 0, 0];\n\n    /* --------------------------------------------------------------------- */\n\n    export function read(sig: PinKit) {\n        const DHT11_TIMEOUT = 100;      // 100 (us)\n        const buffer: boolean[] = [false, false, false, false, false, false, false, false,\n            false, false, false, false, false, false, false, false,\n            false, false, false, false, false, false, false, false,\n            false, false, false, false, false, false, false, false,\n            false, false, false, false, false, false, false, false];\n        const data: number[] = [0, 0, 0, 0, 0];\n        let _startTime = 0;\n\n        /* Port? */\n        let pin;\n        switch (sig) {\n            case PinKit.P0: pin = DigitalPin.P0; break;\n            case PinKit.P1: pin = DigitalPin.P1; break;\n            case PinKit.P2: pin = DigitalPin.P2; break;\n            case PinKit.P13: pin = DigitalPin.P13; break;\n            case PinKit.P14: pin = DigitalPin.P14; break;\n            case PinKit.P15: pin = DigitalPin.P15; break;\n        }\n\n        /* 1. Start Signal */\n        pins.digitalWritePin(pin, 0);   // Set data line LOW\n        basic.pause(18);                // At least 18ms\n\n        /* 2. End the \"Start Signal\" */\n        pins.setPull(pin, PinPullMode.PullUp);\n        pins.digitalReadPin(pin);\n        control.waitMicros(40);         // Delay a moment (20us - 40us) to let sensor pull data line LOW\n\n        /* 3. DHT Response */\n        _startTime = control.micros();\n        while (pins.digitalReadPin(pin) === 0) {        // LOW 80us\n            if (control.micros() - _startTime > DHT11_TIMEOUT) break;\n        }\n        _startTime = control.micros();\n        while (pins.digitalReadPin(pin) === 1) {        // HIGH 80us\n            if (control.micros() - _startTime > DHT11_TIMEOUT) break;\n        }\n\n        /* 4. Read Data - 40 bit */\n        for (let dataBits = 0; dataBits < 40; dataBits++) {\n            _startTime = control.micros();\n            while (pins.digitalReadPin(pin) === 1) {\n                if (control.micros() - _startTime > DHT11_TIMEOUT) break;\n            }\n            _startTime = control.micros();\n            while (pins.digitalReadPin(pin) === 0) {    // LOW 50us\n                if (control.micros() - _startTime > DHT11_TIMEOUT) break;\n            }\n\n            /**\n             * If sensor still pull up data pin after 28 us it means 1, otherwise 0\n             * \n             * Data 1 : HIGH 70us\n             * Data 0 : LOW (26us - 28us)\n             */\n            control.waitMicros(28);\n            if (pins.digitalReadPin(pin) === 1) {\n                buffer[dataBits] = true;\n            }\n        }\n\n        /**\n         * Convert byte number array to integer\n         * The ** operator is exponentiation \n         */\n        for (let i = 0; i < 5; i++) {\n            for (let j = 0; j < 8; j++) {\n                if (buffer[8 * i + j] === true) {\n                    data[i] += 2 ** (7 - j);\n                }\n            }\n        }\n\n        //! Use for Debug\n        // serial.writeNumber(data[0]); serial.writeLine(\" [0]\");\n        // serial.writeNumber(data[1]); serial.writeLine(\" [1]\");\n        // serial.writeNumber(data[2]); serial.writeLine(\" [2]\");\n        // serial.writeNumber(data[3]); serial.writeLine(\" [3]\");\n        // serial.writeNumber(data[4]); serial.writeLine(\" [4]\");\n\n        /* 5. Verify Checksum */\n        if (((data[0] + data[1] + data[2] + data[3]) & 0xFF) === data[4]) {\n            _humidity[sig] = data[0] + data[1] * 0.1;\n            _temperature[sig] = data[2] + data[3] * 0.1;\n        }\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * Read the ambient air temperature\n     * @param sig signal pin (default P0)\n     * @param unit desired conversion unit\n     */\n    //% block=\"S14 Temp&Humi \\\\| Read temperature in degree $unit from port $sig\"\n    //% unit.defl=TemperatureType.Celsius\n    //% sig.defl=PinKit.P0 sig.fieldEditor=\"gridpicker\" sig.fieldOptions.columns=3\n    //% inlineInputMode=inline\n    //% weight=2\n    export function readTemperature(unit: TemperatureType, sig: PinKit): number {\n        read(sig);\n        switch (unit) {\n            case TemperatureType.Celsius: return _temperature[sig];\n            case TemperatureType.Fahrenheit: return (_temperature[sig] * 1.8 + 32);\n        }\n    }\n\n    /**\n     * Read ambient air humidity\n     * @param sig signal pin (default P0)\n     */\n    //% block=\"S14 Temp&Humi \\\\| Read air humidity (\\\\%) from port $sig\"\n    //% sig.defl=PinKit.P0 sig.fieldEditor=\"gridpicker\" sig.fieldOptions.columns=3\n    //% inlineInputMode=inline\n    //% weight=1\n    export function readHumidity(sig: PinKit): number {\n        read(sig);\n        return _humidity[sig];\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/*                               SENSOR DS18B20                              */\n/* ------------------------------------------------------------------------- */\n\n//! pxt-ds18b20\n\n//% color=\"#41C0B5\" weight=5 icon=\"\\uf2c9\" block=\"S15\"\nnamespace ds18b20 {\n    export enum TemperatureType {\n        //% block=\"¬∞C\"\n        Celsius = 0,\n        //% block=\"¬∞F\"\n        Fahrenheit = 1\n    }\n\n    export enum PinKit {\n        //% block=\"P0\"\n        P0 = 0,\n        //% block=\"P1\"\n        P1 = 1,\n        //% block=\"P2\"\n        P2 = 2,\n        //% block=\"P13\"\n        P13 = 3,\n        //% block=\"P14\"\n        P14 = 4,\n        //% block=\"P15\"\n        P15 = 5\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    let ack = 0;\n    let sc_byte = 0;\n    let dat = 0;\n\n    let low = 0;\n    let high = 0;\n\n    let temperature = 0;\n\n    /* Store values for each sensor using separate Pin */\n    const _lastTemp: number[] = [0, 0, 0, 0, 0, 0];\n\n    /* --------------------------------------------------------------------- */\n\n    /* Reset Pulses\n    **\n    ** All communication with the DS18B20 begins with an initialization sequence\n    ** That consists of a reset pulse from the master followed by a presence pulse from the DS18B20\n    **\n    ** During the initialization sequence\n    ** The bus master transmits (TX) the reset pulse by pulling the 1-Wire bus low for a minimum of 480¬µs\n    */\n    export function init(pin: DigitalPin) {\n        pins.digitalWritePin(pin, 0);\n        control.waitMicros(600);    // MASTER Tx RESET PULSE\n\n        pins.digitalWritePin(pin, 1);\n        control.waitMicros(30);     // DS18B20 WAITS\n\n        /* Presence Pulses\n        **\n        ** The bus master then releases the bus and goes into receive mode (RX)\n        ** When the DS18B20 detects this rising edge, it waits 15¬µs to 60¬µs\n        ** And then transmits a presence pulse by pulling the 1-Wire bus low for 60¬µs to 240¬µs\n        */\n        ack = pins.digitalReadPin(pin);\n        control.waitMicros(600);\n\n        return ack;\n    }\n\n    /* Write Time Slots\n    **\n    ** The bus master uses a Write 1 time slot to write a logic 1 to the DS18B20\n    ** And a Write 0 time slot to write a logic 0 to the DS18B20\n    **\n    ** All write time slots must be a minimum of 60¬µs in duration\n    ** With a minimum of a 1¬µs recovery time between individual write slots\n    **\n    ** To generate a Write 1 time slot, after pulling the 1-Wire bus low\n    ** The bus master must release the 1-Wire bus within 15¬µs\n    **\n    ** To generate a Write 0 time slot, after pulling the 1-Wire bus low\n    ** The bus master must continue to hold the bus low for the duration of the time slot (at least 60¬µs)\n    */\n    export function write(pin: DigitalPin, data: number) {\n        sc_byte = 0x01;\n\n        for (let index = 0; index < 8; index++) {\n            pins.digitalWritePin(pin, 0);   // Master pull LOW\n\n            if (data & sc_byte) {           // Write bit 1\n                pins.digitalWritePin(pin, 1);\n                control.waitMicros(60);\n            } else {                        // Write bit 0\n                pins.digitalWritePin(pin, 0);\n                control.waitMicros(60);\n            }\n\n            pins.digitalWritePin(pin, 1);   // Master release\n            data = data >> 1;\n        }\n    }\n\n    /* Read Time Slots\n    **\n    ** The DS18B20 can only transmit data to the master when the master issues read time slots\n    ** Therefore, the master must generate read time slots\n    **\n    ** All read time slots must be a minimum of 60¬µs in duration\n    ** With a minimum of a 1¬µs recovery time between slots\n    **\n    ** The master device pulling the 1-Wire bus low for a minimum of 1¬µs and then releasing the bus\n    ** The DS18B20 will begin transmitting a 1 or 0 on bus\n    **\n    ** The master must release the bus and then sample the bus state within 15¬µs from the start of the slot\n    ** The DS18B20 transmits a 1 by leaving the bus high and transmits a 0 by pulling the bus low\n    */\n    export function read(pin: DigitalPin) {\n        dat = 0x00;\n        sc_byte = 0x01;\n\n        for (let index = 0; index < 8; index++) {\n            pins.digitalWritePin(pin, 0);   // Master pull LOW\n            pins.digitalWritePin(pin, 1);   // Master release\n\n            if (pins.digitalReadPin(pin)) {\n                dat = dat + sc_byte;\n            }\n            sc_byte = sc_byte << 1;         // Read value of 1 bit\n            control.waitMicros(60);\n        }\n\n        return dat;\n    }\n\n    /* Read Scratchpad [BEh]\n    **\n    ** The data transfer starts with the least significant bit of byte 0\n    ** And continues through the scratchpad until the 9th byte (byte 8 ‚Äì CRC) is read\n    **\n    ** Byte 0 : TEMPERATURE LSB\n    ** Byte 1 : TEMPERATURE MSB\n    ** Byte 2 : TH REGISTER OR USER BYTE 1\n    ** Byte 3 : TL REGISTER OR USER BYTE 2\n    ** Byte 4 : CONFIGURATION REGISTER\n    ** Byte 5 : RESERVED\n    ** Byte 6 : RESERVED\n    ** Byte 7 : RESERVED\n    ** Byte 8 : CRC\n    */\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * Read the ambient air temperature\n     * @param unit desired conversion unit\n     * @param sig signal pin (default P0)\n     */\n    //% block=\"S15 Water Temp \\\\| Read temperature in degree $unit from port $sig\"\n    //% unit.defl=TemperatureType.Celsius\n    //% sig.defl=PinKit.P0 sig.fieldEditor=\"gridpicker\" sig.fieldOptions.columns=3\n    //% inlineInputMode=inline\n    export function readTemperature(sig: PinKit, unit: TemperatureType): number {\n        /* Port? */\n        let pin;\n        switch (sig) {\n            case PinKit.P0: pin = DigitalPin.P0; break;\n            case PinKit.P1: pin = DigitalPin.P1; break;\n            case PinKit.P2: pin = DigitalPin.P2; break;\n            case PinKit.P13: pin = DigitalPin.P13; break;\n            case PinKit.P14: pin = DigitalPin.P14; break;\n            case PinKit.P15: pin = DigitalPin.P15; break;\n        }\n\n        /* Transaction Sequence\n        **\n        ** The transaction sequence for accessing the DS18B20 is as follows:\n        ** Step 1. Initialization\n        ** Step 2. ROM Command\n        ** Step 3. DS18B20 Function Command\n        */\n        init(pin);          // Reset Pulses, then Presence Pulses\n        write(pin, 0xCC);   // ROM Commands       : Skip Rom [CCh]\n        write(pin, 0x44);   // Function Commands  : Convert T [44h]\n        \n        /* The 1-Wire bus must be switched to the strong pullup within 10¬µs (max)\n        ** After a Convert T [44h] or Copy Scratchpad [48h] command is issued\n        ** And the bus must be held high by the pullup for the duration of the conversion (tCONV) or data transfer (tWR = 10ms)\n        ** No other activity can take place on the 1-Wire bus while the pullup is enabled\n        **\n        ** 12-bit resolution. tCONV max is 750ms\n        */\n        basic.pause(10);    //! Temperature Conversion Time (tCONV)\n\n        init(pin);          // Reset Pulses, then Presence Pulses\n        write(pin, 0xCC);   // ROM Commands       : Skip Rom [CCh]\n        write(pin, 0xBE);   // Function Commands  : Read Scratchpad [BEh]\n\n        low = read(pin);\n        high = read(pin);\n\n        /*     |--- MS BYTE -----------------------|   |--- LS BYTE -----------------------|\n        ** Bit 15 - 14 - 13 - 12 - 11 - 10 - 09 - 08 - 07 - 06 - 05 - 04 - 03 - 02 - 01 - 00\n        **      S    S    S    S    S   2^+6 2^+5 2^+4 2^+3 2^+2 2^+1 2^+0 2^-1 2^-2 2^-3 2^-4\n        **\n        ** Negative Numbers S = 1\n        ** Positive Numbers S = 0\n        */\n        temperature = high << 8 | low;\n        temperature = temperature / 16;\n        if (temperature > 130) {\n            temperature = _lastTemp[sig];\n        }\n        _lastTemp[sig] = temperature;\n\n        let value;\n        \n        /* Get value temperature */\n        switch (unit) {\n            case TemperatureType.Celsius: value = _lastTemp[sig]; break;\n            case TemperatureType.Fahrenheit: value = (_lastTemp[sig] * 1.8 + 32); break;\n        }\n\n        /* Take only 2 decimal places */\n        value = value * 100;\n        value = Math.trunc(value);\n        value = value / 100;\n\n        return value;\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/*                                 MODULE LCD                                */\n/* ------------------------------------------------------------------------- */\n\n//! pxt-lcd\n\n//% color=\"#FEBC68\" weight=4 icon=\"\\uf26c\" block=\"M07/08\"\n//% groups=\"['Display', 'Clear']\"\nnamespace lcd {\n    /**\n     * Driver PCF8574\n     * 0x27 (39) - default\n     */\n    export enum Address {\n        //% block=\"0x27 (39)\"\n        add39 = 39,\n        //% block=\"0x26 (38)\"\n        add38 = 38,\n        //% block=\"0x25 (37)\"\n        add37 = 37,\n        //% block=\"0x24 (36)\"\n        add36 = 36,\n        //% block=\"0x23 (35)\"\n        add35 = 35,\n        //% block=\"0x22 (34)\"\n        add34 = 34,\n        //% block=\"0x21 (33)\"\n        add33 = 33,\n        //% block=\"0x20 (32)\"\n        add32 = 32\n    }\n\n    /* https://mil.ufl.edu/3744/docs/lcdmanual/characterset.html */\n    export enum Symbols {\n        //% block=\"¬•\"\n        sym01 = 92,\n        //% block=\"‚Üí\"\n        sym02 = 126,\n        //% block=\"‚Üê\"\n        sym03 = 127,\n        //% block=\"‚åú\"\n        sym04 = 162,\n        //% block=\"‚åü\"\n        sym05 = 163,\n        //% block=\"¬∑\"\n        sym06 = 165,\n        //% block=\"¬∞\"\n        sym07 = 223,\n        //% block=\"‚é∑\"\n        sym08 = 232,\n        //% block=\"‚àû\"\n        sym09 = 243,\n        //% block=\"Œ©\"\n        sym10 = 244,\n        //% block=\"Œ£\"\n        sym11 = 246,\n        //% block=\"œÄ\"\n        sym12 = 247,\n        //% block=\"√∑\"\n        sym13 = 253\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * D7 | D6 | D5 | D4 | xx | EN | RW | RS    <-> LCD\n     * P7   P6   P5   P4   P3   P2   P1   P0    <-> I2C\n     *\n     * EN : Starts Data Read/Write\n     * RW : Selects Read (1) or Write (0)\n     * RS : Selects Registers\n     *      | 0 = Instruction Register (IR), for Write \"Busy Flag (BF)\"\n     *      |     Address Counter (AC), for Read\n     *      | 1 = Data Register (DR), for Write and Read\n     *\n     * 0x3F (63) : PCF8574A\n     * 0x27 (39) : PCF8574\n     */\n    let _i2cAddr = Address.add39;\n\n    /**\n     * RS | RW | D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0  <-> Instructions\n     * 0    0    0    0    0    0    1    D    C    B   <-> Display on/off control\n     *                                                      D = 0; Display off\n     *                                                      C = 0; Cursor off\n     *                                                      B = 0; Blinking off\n     * BackLight    : 0x00\n     * No BackLight : 0x08\n     */\n    let _BK = 0x00;\n\n    /**\n     * Register Select Bit\n     *\n     * RS is the LSB in protocol I2C\n     * So that means when RS = 0x00, sends a command (IR)\n     * Otherwise when RS = 0x01, sends data (DR)\n     */\n    let _RS = 0x00;\n\n    const _initOneTime: boolean[] = [false, false, false, false, false, false, false, false];\n\n    /* --------------------------------------------------------------------- */\n\n    /* Send via I2C */\n    export function setReg(d: number) {\n        pins.i2cWriteNumber(_i2cAddr, d, NumberFormat.UInt8LE);\n    }\n\n    /* Send data to I2C bus */\n    export function set(d: number) {\n        d = d & 0xF0;\n        d = d + _BK + _RS;\n\n        setReg(d);              // expanderWrite()\n        /**\n         * pulseEnable()\n         * \n         * EN is the 3rd bit in the I2C protocol\n         * So when EN high = 0x04, opposite EN low = 0x00\n         */\n        setReg(d + 0x04);       // EN high\n        control.waitMicros(1);  // Enable pulse must be >450ns\n        setReg(d);              // EN low\n        control.waitMicros(50); // Commands need > 37us to settle\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /* Send command (IR) */\n    export function cmd(d: number) {\n        _RS = 0x00;\n\n        set(d);\n        set(d << 4);\n    }\n\n    /* Send data (DR) */\n    export function dat(d: number) {\n        _RS = 0x01;\n\n        set(d);\n        set(d << 4);\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /* LCD initialization */\n    export function initLCD(addr: number) {\n        _i2cAddr = addr;\n        _BK = 0x00;\n        _RS = 0x00;\n\n        /**\n         * INITIALIZATION SPECIFICATION!\n         * \n         * According to datasheet, we need at least 40ms after power rises above 2.7V\n         */\n        basic.pause(50);\n\n        /**\n         * Now we pull both RS and R/W low to begin commands\n         * Reset expanderand turn backlight off\n         */\n        setReg(0x00);\n        basic.pause(1000);\n\n        /**\n         * Put the LCD into 4-bit mode\n         * We start in 8-bit mode, try to set 4-bit mode\n         */\n        set(0x30);                  //\n        control.waitMicros(4500);   // Wait min 4.1ms\n        set(0x30);                  // Second try!\n        control.waitMicros(4500);   // Wait min 4.1ms\n        set(0x30);                  // Third go!\n        control.waitMicros(150);    //\n        set(0x20);                  // Finally, set to 4-bit interface\n\n        /* Set # lines, font size, etc. */\n        cmd(0x28);\n\n        /* Turn the display on with no cursor or blinking default */\n        cmd(0x0C);\n\n        /* Clear it off */\n        cmd(0x01);\n        basic.pause(2); // This command takes a long time!\n\n        /**\n         * Initialize to default text direction (for roman languages)\n         * Then set the entry mode\n         */\n        cmd(0x06);\n\n        /* Go home ... set cursor position to zero */\n        cmd(0x02);\n        basic.pause(2); // This command takes a long time!\n\n        _BK = 0x08;\n        _RS = 0x00;\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * Show a string into LCD at a given position\n     * @param text is the string will be shown\n     * @param col is LCD column position\n     * @param row is LCD row position\n     * @param addr fixed address is (0x27), not allowed to change\n     */\n    //% block=\"M07/08 LCD I2C \\\\| Print $text at Column $col and Row $row\"\n    //% text.defl=\"MakerEDU\"\n    //% col.defl=1 col.min=1 col.max=20\n    //% row.defl=1 row.min=1 row.max=4\n    //% inlineInputMode=inline\n    //% weight=3\n    //% group=\"Display\"\n    export function displayText(text: string, col: number, row: number, addr: Address = Address.add39) {\n        /* Make sure to initialize each LCD once */\n        if (!_initOneTime[addr - 32]) {\n            initLCD(addr);\n            _initOneTime[addr - 32] = true;\n        }\n\n        _i2cAddr = addr;\n\n        /* Set cursor position to print */\n        let cursor: number;\n        switch (row - 1) {\n            /**\n             * RS | RW | D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0  <-> Instructions\n             * 0    0    1    ADD  ADD  ADD  ADD  ADD  ADD  ADD <-> Set DDRAM address\n             * \n             * DDRAM address (hexadecimal):\n             * \n             *          C00 C01 C02 C03 C04 C05 C06 C07 C08 C09 C10 C11 C12 C13 C14 C15 C16 C17 C18 C19\n             *      -------------------------------------------------------------------------------------\n             * R00  |   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  10  11  12  13  |\n             * R01  |   40  41  42  43  44  45  46  47  48  49  4A  4B  4C  4D  4E  4F  50  51  52  53  |\n             * R02  |   14  15  16  17  18  19  1A  1B  1C  1D  1E  1F  20  21  22  23  24  25  26  27  |\n             * R03  |   54  55  56  57  58  59  5A  5B  5C  5D  5E  5F  60  61  62  63  64  65  66  67  |\n             *      -------------------------------------------------------------------------------------\n             */\n            case 0: cursor = 0x80; break;\n            case 1: cursor = 0xC0; break;   // 0x80 + 0x40\n            case 2: cursor = 0x94; break;   // 0x80 + 0x14\n            case 3: cursor = 0xD4; break;   // 0xC0 + 0x14\n        }\n        cursor += (col - 1);\n        cmd(cursor);\n\n        /* Do not print overflow character */\n        let overflow: number;\n        if (text.length <= 20 - (col - 1))\n            overflow = text.length;\n        else\n            overflow = 20 - (col - 1);\n        for (let i = 0; i < overflow; i++)\n            dat(text.charCodeAt(i));\n    }\n\n    /**\n     * Select special character to print on the LCD screen\n     * @param sym is special character you choose\n     */\n    //% block=\"Special character $sym\"\n    //% sym.defl=Symbols.sym01 sym.fieldEditor=\"gridpicker\" sym.fieldOptions.columns=4\n    //% inlineInputMode=inline\n    //% weight=2\n    //% group=\"Display\"\n    export function displaySymbol(sym: Symbols): string {\n        return String.fromCharCode(sym);\n    }\n\n    /**\n     * Clear all display content\n     * @param addr fixed address is (0x27), not allowed to change\n     */\n    //% block=\"M07/08 LCD I2C \\\\| Clear all\"\n    //% inlineInputMode=inline\n    //% weight=1\n    //% group=\"Clear\"\n    export function clearScreen(addr: Address = Address.add39) {\n        /* Make sure to initialize each LCD once */\n        if (!_initOneTime[addr - 32]) {\n            initLCD(addr);\n            _initOneTime[addr - 32] = true;\n        }\n\n        _i2cAddr = addr;\n        /**\n         * RS | RW | D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0  <-> Instructions\n         * 0    0    0    0    0    0    0    0    0    1   <-> Clear display\n         */\n        cmd(0x01);\n        basic.pause(2); // This command takes a long time!\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/*                               MODULE DS3231                               */\n/* ------------------------------------------------------------------------- */\n\n//! pxt-ds3231\n\n//% color=\"#FEBC68\" weight=3 icon=\"\\uf017\" block=\"M09\"\n//% groups=\"['Get Info Time (Data)', 'Get Info Time (Text)', 'Setting Time', 'Alarm']\"\nnamespace ds3231 {\n    export enum Calendar {\n        //% block=\"Day\"\n        Day = 0,\n        //% block=\"Month\"\n        Month = 1,\n        //% block=\"Year\"\n        Year = 2\n    }\n\n    export enum Clock {\n        //% block=\"Hour\"\n        Hour = 0,\n        //% block=\"Minute\"\n        Minute = 1,\n        //% block=\"Second\"\n        Second = 2\n    }\n\n    export enum Month {\n        //% block=\"Jan\"\n        Jan = 1,\n        //% block=\"Feb\"\n        Feb = 2,\n        //% block=\"Mar\"\n        Mar = 3,\n        //% block=\"Apr\"\n        Apr = 4,\n        //% block=\"May\"\n        May = 5,\n        //% block=\"Jun\"\n        Jun = 6,\n        //% block=\"Jul\"\n        Jul = 7,\n        //% block=\"Aug\"\n        Aug = 8,\n        //% block=\"Sep\"\n        Sep = 9,\n        //% block=\"Oct\"\n        Oct = 10,\n        //% block=\"Nov\"\n        Nov = 11,\n        //% block=\"Dec\"\n        Dec = 12\n    }\n\n    export enum Alarm {\n        //% block=\"one time\"\n        OneTime = 1,\n        //% block=\"always\"\n        Always = 0\n    }\n\n    /**\n     * Note: the value \"Day of the Week\" store in DS3231\n     * Have value from [1 - 7], with value 1 mean Sunday, 2 is Monday, and so on ...\n     * \n     *      ENUM - DS3231  - ISO_8601 (the Week begin Monday, not Sunday)\n     * Sun  0    - 1       - 7\n     * Mon  1    - 2       - 1\n     * Tue  2    - 3       - 2\n     * Wed  3    - 4       - 3\n     * Thu  4    - 5       - 4\n     * Fri  5    - 6       - 5\n     * Sat  6    - 7       - 6\n     */\n    export enum DayOfWeek {\n        Sun, Mon, Tue, Wed, Thu, Fri, Sat\n    }\n\n    const alarm: number[] = [-1, -1];   // [Hour:Minute]\n    let typeAlarm = Alarm.OneTime;      // Alarm one time!\n\n    /* --------------------------------------------------------------------- */\n\n    const DS3231_I2C_ADDR = 0x68; // Fixed I2C address\n\n    const DS3231_REG_SECOND = 0x00;\n    const DS3231_REG_MINUTE = 0x01;\n    const DS3231_REG_HOUR = 0x02;\n    const DS3231_REG_DAY = 0x03;\n    const DS3231_REG_DATE = 0x04;\n    const DS3231_REG_MONTH = 0x05;\n    const DS3231_REG_YEAR = 0x06;\n\n    /* --------------------------------------------------------------------- */\n\n    /* Set a DS3231 reg */\n    export function setReg(reg: number, dat: number) {\n        let buf = pins.createBuffer(2);\n\n        buf[0] = reg;\n        buf[1] = dat;\n\n        pins.i2cWriteBuffer(DS3231_I2C_ADDR, buf);\n    }\n\n    /* Get a DS3231 reg value */\n    export function regValue(reg: number): number {\n        pins.i2cWriteNumber(DS3231_I2C_ADDR, reg, NumberFormat.UInt8LE);\n\n        return pins.i2cReadNumber(DS3231_I2C_ADDR, NumberFormat.UInt8LE);\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * Convert a \"Binary Coded Decimal\" value to Binary\n     * \n     * RTC stores time/date values as BCD\n     * \n     * Old Recipe:  ( BCD >> 4 ) * 10 + ( BCD & 0x0F )\n     * New Recipe:  BCD - 6 * ( BCD >> 4 )\n     */\n    export function bcdToDec(bcd: number): number {\n        return bcd - 6 * (bcd >> 4);\n    }\n\n    /**\n     * Convert a Binary value to BCD format for the RTC registers\n     * \n     * The format BCD does not store value DEC in normal format of Binary\n     * It use 4 bit corresponding for 10 digit \"0-9\" that is 10 number from \"0-9\"\n     * With 4bit MSB for \"Digit x10\", and 4 bit LSB for \"Digit x1\"\n     * \n     * Old Recipe:  ( ( DEC / 10 ) << 4 ) + ( DEC % 10 )\n     * New Recipe:  DEC + 6 * ( DEC / 10 )\n     */\n    export function decToBcd(dec: number): number {\n        return dec + 6 * Math.idiv(dec, 10);\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * To determine this \"Date\" of Month of Year is what \"Day of the Week\"?\n     * The Week begin Sunday with number 0\n     * \n     * Way Tomohiko Sakamoto‚Äôs used the \"Doomsday Algorithm\" to determine the Day of the Week!\n     */\n    export function getDayOfWeek(y: number, m: number, d: number): number {\n        const monthTable: number[] = [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4];\n\n        y -= ((m < 3) ? 1 : 0);\n\n        return ((y + Math.idiv(y, 4) - Math.idiv(y, 100) + Math.idiv(y, 400) + monthTable[m - 1] + d) % 7);\n    }\n\n    /**\n     * Mapping the value \"Day\" from \"Tomohiko Sakamoto\" to \"ISO_8601\"\n     */\n    export function getDS3231DayOfWeek(y: number, m: number, d: number): number {\n        switch (getDayOfWeek(y, m, d)) {\n            case DayOfWeek.Sun: return 1;\n            case DayOfWeek.Mon: return 2;\n            case DayOfWeek.Tue: return 3;\n            case DayOfWeek.Wed: return 4;\n            case DayOfWeek.Thu: return 5;\n            case DayOfWeek.Fri: return 6;\n            case DayOfWeek.Sat: return 7;\n            default: return 0;\n        }\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    //% shim=ds3231::get_DATE\n    export function get_DATE(): string {\n        return \"?\";\n    }\n\n    //% shim=ds3231::get_TIME\n    export function get_TIME(): string {\n        return \"?\";\n    }\n\n    //! Use for Debug\n    // //% block=\"DS3231 \\\\| Print DATE\"\n    // export function print_DATE(): string {\n    //     return get_DATE();\n    // }\n\n    //! Use for Debug\n    // //% block=\"DS3231 \\\\| Print TIME\"\n    // export function print_TIME(): string {\n    //     return get_TIME();\n    // }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * Get Day, Month, Year data from DS3231\n     * @param calendar select get data Day, Month or Year\n     */\n    //% block=\"M09 Clock I2C \\\\| Get $calendar in Calendar\"\n    //% calendar.defl=Calendar.Day\n    //% inlineInputMode=inline\n    //% weight=11\n    //% group=\"Get Info Time (Data)\"\n    export function getDayMonthYear(calendar: Calendar): number {\n        switch (calendar) {\n            case Calendar.Day: return bcdToDec(regValue(DS3231_REG_DATE));\n            case Calendar.Month: return bcdToDec(regValue(DS3231_REG_MONTH));\n            case Calendar.Year: return bcdToDec(regValue(DS3231_REG_YEAR)) + 2000;\n        }\n    }\n\n    /**\n     * Get \"Date of Week\" data from DS3231\n     */\n    //% block=\"M09 Clock I2C \\\\| Get Days of the Week\"\n    //% inlineInputMode=inline\n    //% weight=10\n    //% group=\"Get Info Time (Data)\"\n    export function getDate(): string {\n        switch (regValue(DS3231_REG_DAY)) {\n            case 1: return \"Sun\";\n            case 2: return \"Mon\";\n            case 3: return \"Tue\";\n            case 4: return \"Wed\";\n            case 5: return \"Thu\";\n            case 6: return \"Fri\";\n            case 7: return \"Sat\";\n            default: return \"---\";\n        }\n    }\n\n    /**\n     * Get Hour, Minute, Second data from DS3231\n     * @param clock select get data Hour, Minute or Second\n     */\n    //% block=\"M09 Clock I2C \\\\| Get $clock in Time now\"\n    //% clock.defl=Clock.Hour\n    //% inlineInputMode=inline\n    //% weight=9\n    //% group=\"Get Info Time (Data)\"\n    export function getHourMinuteSecond(clock: Clock): number {\n        switch (clock) {\n            case Clock.Hour: return bcdToDec(regValue(DS3231_REG_HOUR));\n            case Clock.Minute: return bcdToDec(regValue(DS3231_REG_MINUTE));\n            case Clock.Second: return bcdToDec(regValue(DS3231_REG_SECOND));\n        }\n    }\n\n    /**\n     * Get aggregated __DATE__ data\n     */\n    //% block=\"M09 Clock I2C \\\\| Get Calendar\"\n    //% inlineInputMode=inline\n    //% weight=8\n    //% group=\"Get Info Time (Text)\"\n    export function getCalendar(): string {\n        let d = bcdToDec(regValue(DS3231_REG_DATE));\n        let m = bcdToDec(regValue(DS3231_REG_MONTH));\n        let y = bcdToDec(regValue(DS3231_REG_YEAR)) + 2000;\n\n        let t = \"\";\n        t = t + getDate() + \",\";\n        (d < 10) ? (t = t + \"0\" + convertToText(d) + \"/\") : (t = t + convertToText(d) + \"/\");\n        (m < 10) ? (t = t + \"0\" + convertToText(m) + \"/\") : (t = t + convertToText(m) + \"/\");\n        t += y;\n\n        return t;\n    }\n\n    /**\n     * Get aggregated __TIME__ data\n     */\n    //% block=\"M09 Clock I2C \\\\| Get Time now\"\n    //% inlineInputMode=inline\n    //% weight=7\n    //% group=\"Get Info Time (Text)\"\n    export function getTime(): string {\n        let h = bcdToDec(regValue(DS3231_REG_HOUR));\n        let m = bcdToDec(regValue(DS3231_REG_MINUTE));\n        let s = bcdToDec(regValue(DS3231_REG_SECOND));\n\n        let t = \"\";\n        (h < 10) ? (t = t + \"0\" + convertToText(h) + \":\") : (t = t + convertToText(h) + \":\");\n        (m < 10) ? (t = t + \"0\" + convertToText(m) + \":\") : (t = t + convertToText(m) + \":\");\n        (s < 10) ? (t = t + \"0\" + convertToText(s)) : (t = t + convertToText(s));\n\n        return t;\n    }\n\n    // /**\n    //  * !\n    //  */\n    // //% block=\"DS3231 \\\\| Set Date & Time this sketch was compiled\"\n    // //% inlineInputMode=inline\n    // //% weight=6\n    // //% group=\"Setting Time\"\n    // export function setTime_byCompiled() {\n    //     let s = \"\";\n\n    //     s = get_DATE(); // mmm dd yyyy\n    //     let DATE = s.split(\" \");\n    //     s = get_TIME(); // hh:mm:ss\n    //     let TIME = s.split(\":\");\n\n    //     //! Use for Debug\n    //     // serial.writeLine(DATE[1] + \"-\" + DATE[0] + \"-\" + DATE[2]);\n    //     // serial.writeLine(TIME[0] + \":\" + TIME[1] + \":\" + TIME[2]);\n\n    //     /* ----------------------------------------------------------------- */\n\n    //     let buf = pins.createBuffer(8);\n\n    //     buf[0] = DS3231_REG_SECOND;\n    //     buf[1] = decToBcd(parseInt(TIME[2]));\n    //     buf[2] = decToBcd(parseInt(TIME[1]));\n    //     buf[3] = decToBcd(parseInt(TIME[0]));\n    //     buf[4] = decToBcd(getDS3231DayOfWeek(y, m, d));\n    //     buf[5] = decToBcd(d);\n    //     buf[6] = decToBcd(m);\n    //     buf[7] = decToBcd(y - 2000);\n\n    //     pins.i2cWriteBuffer(DS3231_I2C_ADDR, buf);\n    // }\n\n    /**\n     * Date & Time settings for DS3231\n     * @param day choose Day\n     * @param month choose Month\n     * @param year choose Year\n     * @param hour choose Hour\n     * @param minute choose Minute\n     */\n    //% block=\"M09 Clock I2C \\\\| Set Day $day Month $month Year $year, $hour Hour : $minute Minute : 0 Second\"\n    //% day.defl=1 day.min=1 day.max=31\n    //% month.defl=Month.Jan\n    //% year.defl=2022 year.min=2000 year.max=2099\n    //% hour.defl=11 hour.min=0 hour.max=23\n    //% minute.defl=30 minute.min=0 minute.max=59\n    //% inlineInputMode=inline\n    //% weight=5\n    //% group=\"Setting Time\"\n    export function setTime_byChoose(day: number, month: Month, year: number, hour: number, minute: number) {\n        let buf = pins.createBuffer(8);\n\n        buf[0] = DS3231_REG_SECOND;\n        buf[1] = decToBcd(0);\n        buf[2] = decToBcd(minute);\n        buf[3] = decToBcd(hour);\n        buf[4] = decToBcd(getDS3231DayOfWeek(year, month, day));\n        buf[5] = decToBcd(day);\n        buf[6] = decToBcd(month);\n        buf[7] = decToBcd(year - 2000);\n\n        pins.i2cWriteBuffer(DS3231_I2C_ADDR, buf);\n    }\n\n    /**\n     * Set the Date & Time for the DS3231 using the command\n     * @param setFullTime install by command according to the syntax \"ST-dd/mm/yyyy-hh:mm:ss\"\n     */\n    //% block=\"M09 Clock I2C \\\\| Setting Date & Time $setFullTime\"\n    //% setFullTime.defl=\"ST-15/08/2022-13:13:13\"\n    //% inlineInputMode=inline\n    //% weight=4\n    //% group=\"Setting Time\"\n    export function setTime_byCommands(setFullTime: string): boolean {\n        /**\n         * String handling:\n         * \n         * The command SetTime input correct is: ST-00/00/0000-00:00:00\n         * With value sequence is: ST-Day/Month/Year-Hour:Minute:Second\n         */\n        if (setFullTime.length == 22) {\n            if (setFullTime.includes(\"ST\")) {\n                if (setFullTime[2] != '-') return false;\n                if (setFullTime[5] != '/') return false;\n                if (setFullTime[8] != '/') return false;\n                if (setFullTime[13] != '-') return false;\n                if (setFullTime[16] != ':') return false;\n                if (setFullTime[19] != ':') return false;\n\n                let day = parseInt(setFullTime.substr(3, 2));\n                let month = parseInt(setFullTime.substr(6, 2));\n                let year = parseInt(setFullTime.substr(9, 4));\n\n                let hour = parseInt(setFullTime.substr(14, 2));\n                let minute = parseInt(setFullTime.substr(17, 2));\n                let second = parseInt(setFullTime.substr(20, 2));\n\n                /* --------------------------------------------------------- */\n\n                let buf = pins.createBuffer(8);\n\n                buf[0] = DS3231_REG_SECOND;\n                buf[1] = decToBcd(second);\n                buf[2] = decToBcd(minute);\n                buf[3] = decToBcd(hour);\n                buf[4] = decToBcd(getDS3231DayOfWeek(year, month, day));\n                buf[5] = decToBcd(day);\n                buf[6] = decToBcd(month);\n                buf[7] = decToBcd(year - 2000);\n\n                pins.i2cWriteBuffer(DS3231_I2C_ADDR, buf);\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Alarm settings for DS3231\n     * @param hour choose Hour\n     * @param minute choose Minute\n     * @param types alarm once or every day\n     */\n    //% block=\"M09 Clock I2C \\\\| Set Alarm at $hour Hour : $minute Minute $types\"\n    //% hour.defl=11 hour.min=0 hour.max=23\n    //% minute.defl=30 minute.min=0 minute.max=59\n    //% types.defl=Alarm.OneTime\n    //% inlineInputMode=inline\n    //% weight=3\n    //% group=\"Alarm\"\n    export function setAlarm_byChoose(hour: number, minute: number, types: Alarm) {\n        alarm[0] = hour;\n        alarm[1] = minute;\n        typeAlarm = types;\n    }\n\n    /**\n     * Set the Alarm for the DS3231 using the command\n     * @param ticks install by command according to the syntax \"ST-hh:mm\"\n     * @param types alarm once or every day\n     */\n    //% block=\"M09 Clock I2C \\\\| Setting Alarm $ticks $types\"\n    //% ticks.defl=\"SA-15:30\"\n    //% types.defl=Alarm.OneTime\n    //% inlineInputMode=inline\n    //% weight=2\n    //% group=\"Alarm\"\n    export function setAlarm_byCommands(ticks: string, types: Alarm): boolean {\n        /**\n         * String handling:\n         * \n         * The command SetTime input correct is: SA-00:00\n         * With value sequence is: SA-Hour:Minute\n         */\n        if (ticks.length == 8) {\n            if (ticks.includes(\"SA\")) {\n                if (ticks[2] != '-') return false;\n                if (ticks[5] != ':') return false;\n\n                alarm[0] = parseInt(ticks.substr(3, 2));\n                alarm[1] = parseInt(ticks.substr(6, 2));\n                typeAlarm = types;\n\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Update the time to see if it's time for the alarm\n     */\n    //% block=\"M09 Clock I2C \\\\| Check Alarm üí§‚è∞\"\n    //% inlineInputMode=inline\n    //% weight=1\n    //% group=\"Alarm\"\n    export function checkAlarm(): boolean {\n        if (bcdToDec(regValue(DS3231_REG_HOUR)) == alarm[0]) {\n            if (bcdToDec(regValue(DS3231_REG_MINUTE)) == alarm[1]) {\n                if (typeAlarm == 1) {   // OneTime\n                    alarm[0] = alarm[1] = -1;\n                }\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/*                             MODULE MP3 PLAYER                             */\n/* ------------------------------------------------------------------------- */\n\n/* ------------------------------------------------------------------------- */\n\n//! pxt-mp3Player\n\n//% color=\"#FEBC68\" weight=2 icon=\"\\uf001\" block=\"M11\"\n//% groups=\"['Setting', 'Control', 'Get Info', 'Advanced Control']\"\nnamespace mp3Player {\n    export enum EQ {\n        //% block=\"Normal\"\n        Normal = 0x00,  // DFPLAYER_EQ_NORMAL\n        //% block=\"Pop\"\n        Pop = 0x01,     // DFPLAYER_EQ_POP\n        //% block=\"Rock\"\n        Rock = 0x02,    // DFPLAYER_EQ_ROCK\n        //% block=\"Jazz\"\n        Jazz = 0x03,    // DFPLAYER_EQ_JAZZ\n        //% block=\"Classic\"\n        Classic = 0x04, // DFPLAYER_EQ_CLASSIC\n        //% block=\"Bass\"\n        Bass = 0x05     // DFPLAYER_EQ_BASS\n    }\n\n    export enum PlayWhat {\n        //% block=\"Next\"\n        Next = 0x01,\n        //% block=\"Previous\"\n        Previous = 0x02\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * Serial Mode: Instruction Description\n     * \n     * Format: $S - VER - Len - CMD - Feedback - para1 - para2 - checksum - $O\n     * |\n     * [0] $S       : start bit                         0x7E\n     * [1] VER      : version information               0xFF\n     * [2] Len      : the number of bytes after \"Len\"   0x06\n     * [3] CMD      : indicate the specific operations  -> 1 Byte\n     * [4] Feedback : feedback (1) / no feedback (0)    -> 1 Byte\n     * [5] para1    : query high data byte              -> 1 Byte\n     * [6] para2    : query low data byte               -> 1 Byte\n     * [7] checksum : accumulation and verification     -> 2 Byte\n     * [8]          = 0 - ( [1] + [2] + [3] + [4] + [5] + [6] )\n     * [9] $O       : end bit                           0xEF\n     */\n    const dataArr: number[] = [0x7E, 0xFF, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF];\n\n    const DFPlayerCardInserted: number = 2;\n    const DFPlayerCardRemoved: number = 3;\n    const DFPlayerCardOnline: number = 4;\n    const DFPlayerPlayFinished: number = 5;\n    const DFPlayerError: number = 6;\n    const DFPlayerUSBInserted: number = 7;\n    const DFPlayerUSBRemoved: number = 8;\n    const DFPlayerUSBOnline: number = 9;\n    const DFPlayerCardUSBOnline: number = 10;\n    const DFPlayerFeedBack: number = 11;\n\n    const Stack_Version: number = 1;\n    const Stack_Length: number = 2;\n    const Stack_End: number = 9;\n\n    const TimeOut: number = 0;\n    const WrongStack: number = 1;\n\n    let _isAvailable = false;\n    let _handleType: number;\n    let _handleParameter: number;\n    let _receivedIndex = 0;\n    let _isSending = false;\n    let _handleCommand: number;\n    let _timeOutTimer: number;\n\n    const _received: number[] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    /* --------------------------------------------------------------------- */\n\n    /* Connect to MP3 Player */\n    export function connect() {\n        /**\n         * Configure the serial port to use the pins instead of USB\n         * \n         * function serial.redirect(tx: SerialPin, rx: SerialPin, rate: BaudRate): void;\n         * tx   : the transmit pin to send serial data on\n         * rx   : the receive pin to receive serial data on\n         * rate : the baud rate for transmitting and receiving data\n         * \n         * MP3Player <----> MicroBit\n         * (RX)             P8 (TX)\n         * (TX)             P2 (RX)\n         */\n        serial.redirect(SerialPin.P8, SerialPin.P2, BaudRate.BaudRate9600);\n    }\n\n    /* Calculate Checksum */\n    export function checkSum() {\n        /**\n         * 2 Byte (16 bit)\n         * \n         * 0 - 1 = -1 : 0xFFFF : 65,535 = 65,536 - 1\n         * 0 - 2 = -2 : 0xFFFE : 65,534 = 65,536 - 2\n         * ...\n         */\n        let total = 65536 - (dataArr[1] + dataArr[2] + dataArr[3] + dataArr[4] + dataArr[5] + dataArr[6]);\n\n        dataArr[7] = total >> 8;    // para_H\n        dataArr[8] = total & 0xFF;  // para_L\n    }\n\n    /* Send commands to MP3 Player */\n    export function sendData() {\n        let buf = pins.createBuffer(10);\n\n        for (let index = 0; index < 10; index++) {\n            buf.setNumber(NumberFormat.UInt8LE, index, dataArr[index])\n        }\n        serial.writeBuffer(buf);\n\n        _timeOutTimer = input.runningTime();\n        basic.pause(100);//!\n    }\n\n    /* Start the process of sending commands via Serial */\n    export function innerCall(CMD: number, para1: number, para2: number) {\n        /* Make sure MP3Player is connected */\n        connect();\n\n        dataArr[3] = CMD;\n        dataArr[5] = para1;\n        dataArr[6] = para2;\n\n        checkSum();\n        sendData();\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    export function handleMessage(type: number, parameter: number): boolean {\n        _receivedIndex = 0;\n        _handleType = type;\n        _handleParameter = parameter;\n        _isAvailable = true;\n\n        return _isAvailable;\n    }\n\n    export function handleError(type: number, parameter: number): boolean {\n        handleMessage(type, parameter);\n        _isSending = false;\n\n        return false;\n    }\n\n    export function validateStack(): boolean {\n        let calCheckSum = 65536 - (_received[1] + _received[2] + _received[3] + _received[4] + _received[5] + _received[6]);\n        let revCheckSum = _received[7] * 256 + _received[8];\n\n        return calCheckSum == revCheckSum;\n    }\n\n    export function parseStack() {\n        let handleCommand = _received[3];\n        /**\n         * Handle the 0x41 ack feedback as a spcecial case\n         * In case the pollusion of _handleCommand, _handleParameter, and _handleType\n         */\n        if (handleCommand == 0x41) {\n            _isSending = false;\n            return;\n        }\n\n        _handleCommand = handleCommand;\n        _handleParameter = _received[5] * 256 + _received[6];\n\n        switch (_handleCommand) {\n            case 0x3D:\n                handleMessage(DFPlayerPlayFinished, _handleParameter);\n                break;\n            case 0x3F:\n                if (_handleParameter & 0x01) {\n                    handleMessage(DFPlayerUSBOnline, _handleParameter);\n                }\n                else if (_handleParameter & 0x02) {\n                    handleMessage(DFPlayerCardOnline, _handleParameter);\n                }\n                else if (_handleParameter & 0x03) {\n                    handleMessage(DFPlayerCardUSBOnline, _handleParameter);\n                }\n                break;\n            case 0x3A:\n                if (_handleParameter & 0x01) {\n                    handleMessage(DFPlayerUSBInserted, _handleParameter);\n                }\n                else if (_handleParameter & 0x02) {\n                    handleMessage(DFPlayerCardInserted, _handleParameter);\n                }\n                break;\n            case 0x3B:\n                if (_handleParameter & 0x01) {\n                    handleMessage(DFPlayerUSBRemoved, _handleParameter);\n                }\n                else if (_handleParameter & 0x02) {\n                    handleMessage(DFPlayerCardRemoved, _handleParameter);\n                }\n                break;\n            case 0x40:\n                handleMessage(DFPlayerError, _handleParameter);\n                break;\n            case 0x3C:\n            case 0x3E:\n            case 0x42:\n            case 0x43:\n            case 0x44:\n            case 0x45:\n            case 0x46:\n            case 0x47:\n            case 0x48:\n            case 0x49:\n            case 0x4B:\n            case 0x4C:\n            case 0x4D:\n            case 0x4E:\n            case 0x4F:\n                handleMessage(DFPlayerFeedBack, _handleParameter);\n                break;\n            default:\n                handleError(WrongStack, 0);\n                break;\n        }\n    }\n\n    export function available(): boolean {\n        let data = serial.readBuffer(0);\n        while (_receivedIndex < data.length) {\n            if (_receivedIndex == 0) {\n                _received[0] = data.getNumber(NumberFormat.UInt8LE, 0);\n                if (_received[0] == 0x7E) {\n                    _receivedIndex++;\n                }\n            } else {\n                _received[_receivedIndex] = data.getNumber(NumberFormat.UInt8LE, _receivedIndex);\n\n                switch (_receivedIndex) {\n                    case Stack_Version:\n                        if (_received[_receivedIndex] != 0xFF) {\n                            return handleError(WrongStack, 0);\n                        }\n                        break;\n                    case Stack_Length:\n                        if (_received[_receivedIndex] != 0x06) {\n                            return handleError(WrongStack, 0);\n                        }\n                        break;\n                    case Stack_End:\n                        if (_received[_receivedIndex] != 0xEF) {\n                            return handleError(WrongStack, 0);\n                        } else {\n                            if (validateStack()) {\n                                _receivedIndex = 0;\n                                parseStack();\n                                return _isAvailable;\n                            } else {\n                                return handleError(WrongStack, 0);\n                            }\n                        }\n                    default:\n                        break;\n                }\n\n                _receivedIndex++;\n            }\n        }\n\n        /* Over timeout 500ms */\n        if (_isSending && (input.runningTime() - _timeOutTimer >= 500)) {\n            return handleError(TimeOut, 0);\n        }\n\n        return _isAvailable;\n    }\n\n    export function waitAvailable(): boolean {\n        let wait = input.runningTime();\n        while (!available()) {\n            /* Over timeout 500ms */\n            if (input.runningTime() - wait > 500) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    export function readType(): number {\n        _isAvailable = false;\n        return _handleType;\n    }\n\n    export function read(): number {\n        _isAvailable = false;\n        return _handleParameter;\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    export function readEQ(): number {\n        /* Query the current EQ */\n        innerCall(0x44, 0x00, 0x00);\n\n        if (waitAvailable()) {\n            if (readType() == DFPlayerFeedBack)\n                return read();\n            else\n                return -1;\n        }\n        else {\n            return -1;\n        }\n    }\n\n    export function readFileCounts(): number {\n        /* Query the total number of U-disk files */\n        innerCall(0x48, 0x00, 0x00);\n\n        if (waitAvailable()) {\n            if (readType() == DFPlayerFeedBack)\n                return read();\n            else\n                return -1;\n        }\n        else {\n            return -1;\n        }\n    }\n\n    export function readVolume(): number {\n        /* Query the current volume */\n        innerCall(0x43, 0x00, 0x00);\n\n        if (waitAvailable()) {\n            return read();\n        }\n        else {\n            return -1;\n        }\n    }\n\n    export function getInfoMP3(): string {\n        let info = \"\";\n        let typeEQ = \"\";\n\n        switch (readEQ()) {\n            case 0: typeEQ = \"Normal\"; break;\n            case 1: typeEQ = \"Pop\"; break;\n            case 2: typeEQ = \"Rock\"; break;\n            case 3: typeEQ = \"Jazz\"; break;\n            case 4: typeEQ = \"Classic\"; break;\n            case 5: typeEQ = \"Bass\"; break;\n        }\n\n        info = convertToText(readFileCounts()) + \" files in SD Card.\\n\"\n            + \"Volume \" + convertToText(readVolume()) + \".\\n\"\n            + \"EQ \" + typeEQ + \".\";\n\n        /* Direct the serial input and output to use the USB connection */\n        serial.redirectToUSB();\n        return info;\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /* Stop playing music after a period of time */\n    export function playInPeriod(second: number) {\n        let wait = input.runningTime() + 1000 * second;\n        while (input.runningTime() <= wait) { }\n\n        /* Pause */\n        innerCall(0x0E, 0x00, 0x00);\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    export function waitFinishMusic() {\n        let wrongStack = false;\n        let timeOut = false;\n\n        while (true) {\n            basic.pause(500);//! Interval is set at 400ms\n            if (available()) {\n                if (readType() == DFPlayerPlayFinished) {\n                    break;\n                } else {\n                    if (readType() == WrongStack) { wrongStack = true; }\n                    else if (readType() == TimeOut) { timeOut = true; }\n                    //\n                    if (wrongStack && timeOut) { break; }\n                }\n            }\n        }\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * Perform volume up\n     */\n    //% block=\"M11 MP3 Player \\\\| Up volume from port (P2+P8)\"\n    //% inlineInputMode=inline\n    //% weight=13\n    //% group=\"Setting\"\n    export function upVolume() {\n        // DFRobotDFPlayerMini::volumeUp()\n        innerCall(0x04, 0x00, 0x00);\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Perform volume down\n     */\n    //% block=\"M11 MP3 Player \\\\| Down volume from port (P2+P8)\"\n    //% inlineInputMode=inline\n    //% weight=12\n    //% group=\"Setting\"\n    export function downVolume() {\n        // DFRobotDFPlayerMini::volumeDown()\n        innerCall(0x05, 0x00, 0x00);\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Perform volume adjustment\n     * @param volume select sound level from 0 to 30\n     */\n    //% block=\"M11 MP3 Player \\\\| Set volume level $volume from port (P2+P8)\"\n    //% volume.defl=20 volume.min=0 volume.max=30\n    //% inlineInputMode=inline\n    //% weight=11\n    //% group=\"Setting\"\n    export function setVolume(volume: number) {\n        // DFRobotDFPlayerMini::volume(uint8_t volume)\n        innerCall(0x06, 0x00, volume);\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Adjust the EQ of the sound\n     * @param chooseEQ select EQ format\n     */\n    //% block=\"M11 MP3 Player \\\\| Set EQ $chooseEQ from port (P2+P8)\"\n    //% chooseEQ.defl=EQ.Normal\n    //% inlineInputMode=inline\n    //% weight=10\n    //% group=\"Setting\"\n    export function setEQ(chooseEQ: EQ) {\n        // DFRobotDFPlayerMini::EQ(uint8_t eq)\n        innerCall(0x07, 0x00, chooseEQ);\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Play the music file of your choice\n     * @param file select the music file you want to play\n     */\n    //% block=\"M11 MP3 Player \\\\| Play file number $file from port (P2+P8)\"\n    //% file.defl=1 file.min=0 file.max=65535\n    //% inlineInputMode=inline\n    //% weight=9\n    //% group=\"Control\"\n    export function playFile(file: number) {\n        /**\n         * Play specific mp3 in SD:/MP3/0000.mp3; File Name (0 ~ 65,535)\n         * DFRobotDFPlayerMini::playMp3Folder(int fileNumber)\n         */\n        innerCall(0x12, file >> 8, file & 0xFF);\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Play the next or previous music file compared to the current music file\n     * @param playWhat choose to play next or previous music file\n     */\n    //% block=\"M11 MP3 Player \\\\| Play $playWhat from port (P2+P8)\"\n    //% playWhat.defl=PlayWhat.Next\n    //% inlineInputMode=inline\n    //% weight=8\n    //% group=\"Control\"\n    export function play(playWhat: PlayWhat) {\n        /**\n         * DFRobotDFPlayerMini::next()\n         * DFRobotDFPlayerMini::previous()\n         */\n        innerCall(playWhat, 0x00, 0x00);\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Pause the currently playing file\n     */\n    //% block=\"M11 MP3 Player \\\\| Pause from port (P2+P8)\"\n    //% inlineInputMode=inline\n    //% weight=7\n    //% group=\"Control\"\n    export function pause() {\n        // DFRobotDFPlayerMini::pause()\n        innerCall(0x0E, 0x00, 0x00);\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Play continues with paused file music\n     */\n    //% block=\"M11 MP3 Player \\\\| Start (Play continues) from port (P2+P8)\"\n    //% inlineInputMode=inline\n    //% weight=6\n    //% group=\"Control\"\n    export function start() {\n        // DFRobotDFPlayerMini::start()\n        innerCall(0x0D, 0x00, 0x00);\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Get the parameters being set in MP3 Player\n     */\n    //% block=\"M11 MP3 Player \\\\| Read information setting current from port (P2+P8)\"\n    //% inlineInputMode=inline\n    //% weight=5\n    //% group=\"Get Info\"\n    export function getInfo(): string {\n        return getInfoMP3();\n    }\n\n    /**\n     * Play a music file of your choice for a certain amount of time\n     * @param file select the music file you want to play\n     * @param second set how long you want to play that file\n     */\n    //% block=\"M11 MP3 Player \\\\| Play file number $file for $second seconds from port (P2+P8)\"\n    //% file.defl=1 file.min=0 file.max=65535\n    //% second.defl=2.5\n    //% inlineInputMode=inline\n    //% weight=4\n    //% group=\"Advanced Control\"\n    export function playFileInTime(file: number, second: number) {\n        playFile(file);\n        playInPeriod(second);\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Play the music file of your choice until the song is over\n     * @param file select the music file you want to play\n     */\n    //% block=\"M11 MP3 Player \\\\| Play file number $file until done from port (P2+P8)\"\n    //% file.defl=1 file.min=0 file.max=65535\n    //% inlineInputMode=inline\n    //% weight=3\n    //% group=\"Advanced Control\"\n    export function playFileUntilDone(file: number) {\n        /**\n         * Play specific mp3 in SD:/MP3/0000.mp3; File Name (0 ~ 65,535)\n         * DFRobotDFPlayerMini::playMp3Folder(int fileNumber)\n         */\n        innerCall(0x12, file >> 8, file & 0xFF);\n        waitFinishMusic();\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Play next or previous music file for a certain amount of time\n     * @param playWhat choose to play next or previous music file\n     * @param second set how long you want to play that file\n     */\n    //% block=\"M11 MP3 Player \\\\| Play $playWhat for $second seconds from port (P2+P8)\"\n    //% playWhat.defl=PlayWhat.Next\n    //% second.defl=2.5\n    //% inlineInputMode=inline\n    //% weight=2\n    //% group=\"Advanced Control\"\n    export function playInTime(playWhat: PlayWhat, second: number) {\n        play(playWhat);\n        playInPeriod(second);\n\n        serial.redirectToUSB();\n    }\n\n    /**\n     * Play next or previous music file until the song is over\n     * @param playWhat choose to play next or previous music file\n     */\n    //% block=\"M11 MP3 Player \\\\| Play $playWhat until done from port (P2+P8)\"\n    //% playWhat.defl=PlayWhat.Next\n    //% inlineInputMode=inline\n    //% weight=1\n    //% group=\"Advanced Control\"\n    export function playUntilDone(playWhat: PlayWhat) {\n        /**\n         * DFRobotDFPlayerMini::next()\n         * DFRobotDFPlayerMini::previous()\n         */\n        innerCall(playWhat, 0x00, 0x00);\n        waitFinishMusic();\n\n        serial.redirectToUSB();\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/*                                 BACKGROUND                                */\n/*        https://github.com/1010Technologies/pxt-makerbit-background        */\n/* ------------------------------------------------------------------------- */\n\nnamespace background {\n    export enum Thread {\n        Priority = 0,\n        UserCallback = 1\n    }\n\n    export enum Mode {\n        Repeat,\n        Once\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    class Executor {\n        _newJobs: Job[] = undefined;\n        _jobsToRemove: number[] = undefined;\n        _pause: number = 100;\n        _type: Thread;\n\n        constructor(type: Thread) {\n            this._type = type;\n            this._newJobs = [];\n            this._jobsToRemove = [];\n            control.runInParallel(() => this.loop());\n        }\n\n        push(task: () => void, delay: number, mode: Mode): number {\n            if (delay > 0 && delay < this._pause && mode === Mode.Repeat) {\n                this._pause = Math.floor(delay);\n            }\n            const job = new Job(task, delay, mode);\n            this._newJobs.push(job);\n            return job.id;\n        }\n\n        cancel(jobId: number) {\n            this._jobsToRemove.push(jobId);\n        }\n\n        loop(): void {\n            const _jobs: Job[] = [];\n\n            let previous = control.millis();\n\n            while (true) {\n                const now = control.millis();\n                const delta = now - previous;\n                previous = now;\n\n                // Add new jobs\n                this._newJobs.forEach(function (job: Job, index: number) {\n                    _jobs.push(job);\n                });\n                this._newJobs = [];\n\n                // Cancel jobs\n                this._jobsToRemove.forEach(function (jobId: number, index: number) {\n                    for (let i = _jobs.length - 1; i >= 0; i--) {\n                        const job = _jobs[i];\n                        if (job.id == jobId) {\n                            _jobs.removeAt(i);\n                            break;\n                        }\n                    }\n                });\n                this._jobsToRemove = [];\n\n                // Execute all jobs\n                if (this._type === Thread.Priority) {\n                    // Newest first\n                    for (let i = _jobs.length - 1; i >= 0; i--) {\n                        if (_jobs[i].run(delta)) {\n                            this._jobsToRemove.push(_jobs[i].id);\n                        }\n                    }\n                } else {\n                    // Execute in order of schedule\n                    for (let i = 0; i < _jobs.length; i++) {\n                        if (_jobs[i].run(delta)) {\n                            this._jobsToRemove.push(_jobs[i].id);\n                        }\n                    }\n                }\n\n                basic.pause(this._pause);\n            }\n        }\n    }\n\n    class Job {\n        id: number;\n        func: () => void;\n        delay: number;\n        remaining: number;\n        mode: Mode;\n\n        constructor(func: () => void, delay: number, mode: Mode) {\n            this.id = randint(0, 2147483647);\n            this.func = func;\n            this.delay = delay;\n            this.remaining = delay;\n            this.mode = mode;\n        }\n\n        run(delta: number): boolean {\n            if (delta <= 0) {\n                return false;\n            }\n\n            this.remaining -= delta;\n            if (this.remaining > 0) {\n                return false;\n            }\n\n            switch (this.mode) {\n                case Mode.Once:\n                    this.func();\n                    basic.pause(0);\n                    return true;\n                case Mode.Repeat:\n                    this.func();\n                    this.remaining = this.delay;\n                    basic.pause(0);\n                    return false;\n            }\n        }\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    const queues: Executor[] = [];\n\n    /* --------------------------------------------------------------------- */\n\n    export function schedule(func: () => void, type: Thread, mode: Mode, delay: number): number {\n        if (!func || delay < 0) {\n            return 0;\n        }\n\n        if (!queues[type]) {\n            queues[type] = new Executor(type);\n        }\n\n        return queues[type].push(func, delay, mode);\n    }\n\n    export function remove(type: Thread, jobId: number): void {\n        if (queues[type]) {\n            queues[type].cancel(jobId);\n        }\n    }\n}\n\n/* ------------------------------------------------------------------------- */\n/*                               MODULE IR1838                               */\n/* ------------------------------------------------------------------------- */\n\n//! pxt-ir1838\n\n//% color=\"#FEBC68\" weight=1 icon=\"\\uf00d\" block=\"M14\"\n//% groups=\"['Get Info Infrared (Data)', 'Get Info Infrared (Text)']\"\nnamespace ir1838 {\n    export enum ValueIR {\n        //% block=\"command\"\n        Command = 0,\n        //% block=\"address\"\n        Address = 1,\n        //% block=\"raw data\"\n        RawData = 2\n    }\n\n    /* https://hshop.vn/products/module-dieu-khien-hong-ngoai-tu-xa */\n    export enum IrButton {\n        Any = -1,\n        CH_Minus = 0x45,\n        CH = 0x46,\n        CH_Plus = 0x47,\n        Prev = 0x44,\n        Next = 0x40,\n        Play_Pause = 0x43,\n        Vol_Minus = 0x07,\n        Vol_Plus = 0x15,\n        EQ = 0x09,\n        Number_0 = 0x16,\n        Number_100Plus = 0x19,\n        Number_200Plus = 0x0D,\n        Number_1 = 0x0C,\n        Number_2 = 0x18,\n        Number_3 = 0x5E,\n        Number_4 = 0x08,\n        Number_5 = 0x1C,\n        Number_6 = 0x5A,\n        Number_7 = 0x42,\n        Number_8 = 0x52,\n        Number_9 = 0x4A\n    }\n\n    export enum PinKit {\n        //% block=\"P0\"\n        P0 = 0,\n        //% block=\"P1\"\n        P1 = 1,\n        //% block=\"P2\"\n        P2 = 2,\n        //% block=\"P13\"\n        P13 = 3,\n        //% block=\"P14\"\n        P14 = 4,\n        //% block=\"P15\"\n        P15 = 5\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    const IR_REPEAT = 256;          // Status code indicating \"Repeat Code\" received\n    const IR_INCOMPLETE = 257;      // Status code indicating receipt of 1 signal pulse [ mark + space ]\n    const IR_DATAGRAM = 258;        // Status code indicating full 32 bits of data received\n\n    const REPEAT_TIMEOUT_MS = 120;  // Repeat cycle is >= 110ms\n\n    class IrButtonHandler {\n        irButton: IrButton;\n        onEvent: () => void;\n\n        constructor(irButton: IrButton, onEvent: () => void) {\n            this.irButton = irButton;\n            this.onEvent = onEvent;\n        }\n    }\n\n    interface IrState {\n        hasNewDatagram: boolean;    // Is there any new data sent?\n\n        bitsReceived: number;       // Number of bits received\n\n        hiword: number;             // Temporarily save the raw \"Command\" value\n        loword: number;             // Temporarily save the raw \"Address\" value\n\n        commandSectionBits: number; // Save the complete \"Command\" data\n        addressSectionBits: number; // Save the complete \"Address\" data\n\n        activeCommand: number;      // !\n        repeatTimeout: number;      // Store time for \"Repeat timer refresh\"\n\n        onIrButtonPressed: IrButtonHandler[];   // !\n        onIrButtonReleased: IrButtonHandler[];  // !\n\n        onIrDatagram: () => void;   // !\n    }\n\n    let irState: IrState;\n\n    let _initOneTime = false;\n\n    /* --------------------------------------------------------------------- */\n\n    export function initIrState() {\n        if (irState) {\n            return;\n        }\n\n        irState = {\n            hasNewDatagram: false,\n\n            bitsReceived: 0,\n\n            hiword: 0,\n            loword: 0,\n\n            commandSectionBits: 0,\n            addressSectionBits: 0,\n\n            activeCommand: -1,\n            repeatTimeout: 0,\n\n            onIrButtonPressed: [],\n            onIrButtonReleased: [],\n\n            onIrDatagram: undefined\n        };\n    }\n\n    export function appendBitToDatagram(bit: boolean): number {\n        /**\n         * Because these signals are Logic 0 and 1\n         * So every time received, need +1 to count the number of received data bits\n         */\n        irState.bitsReceived += 1;\n\n        /**\n         * Vd: Number_9 = 0x4A\n         * \n         * |       hiword        |         loword      |\n         * |         |           |           |         |         \n         * | ~Command|   Command |  ~Address | Address |\n         * |         |           |           |         |\n         * |  0xB5   |    0x4A   |    0xFF   |    0x00 |\n         * |         |           |           |         |\n         * 1011.0101 + 0100.1010 | 1111.1111 + 0000.0000\n         * |                                           |\n         * MSB                                         LSB\n         */\n        if (irState.bitsReceived <= 16) {\n            if (bit) {\n                irState.loword = (irState.loword >>> 1) | 0x8000;\n            } else {\n                irState.loword = irState.loword >>> 1;\n            }\n        } else if (irState.bitsReceived <= 32) {\n            if (bit) {\n                irState.hiword = (irState.hiword >>> 1) | 0x8000;\n            } else {\n                irState.hiword = irState.hiword >>> 1;\n            }\n        }\n\n        /**\n         * When full 32 bits are received\n         * Move clipboard data to main memory\n         * Before transferring there is an extra \"filtering\" to ensure that the full 32 bits are received\n         */\n        if (irState.bitsReceived === 32) {\n            irState.commandSectionBits = irState.hiword & 0xFFFF;\n            irState.addressSectionBits = irState.loword & 0xFFFF;\n\n            //! Use for Debug\n            // serial.writeNumber(irState.commandSectionBits); serial.writeLine(\" [C]\");\n            // serial.writeNumber(irState.addressSectionBits); serial.writeLine(\" [A]\");\n\n            return IR_DATAGRAM;\n        } else {\n            return IR_INCOMPLETE;\n        }\n    }\n\n    export function decode(markAndSpace: number): number {\n        if (markAndSpace < 1600) {\n            /**\n             * Logic 0: [mark]  = 562.5us\n             *          [space] = 562.5us\n             * markAndSpace     ~ 1.125ms\n             */\n            return appendBitToDatagram(false);\n        } else if (markAndSpace < 2700) {\n            /**\n             * Logic 1: [mark]  = 562.5us\n             *          [space] = 1,687.5us\n             * markAndSpace     ~ 2.25ms\n             */\n            return appendBitToDatagram(true);\n        }\n\n        /**\n         * Because these signals are not Logic 0 and 1\n         * So we \"Reset\" the number of received data bits to 0\n         */\n        irState.bitsReceived = 0;\n\n        if (markAndSpace < 12500) {\n            /**\n             * ! Repeat detected\n             * \n             * Repeat Code: [mark]  = 9,000us\n             *              [space] = 2,250us\n             * markAndSpace         ~ 11.25ms\n             */\n            return IR_REPEAT;\n        } else if (markAndSpace < 14500) {\n            /**\n             * ! Start detected\n             * \n             * Start of Frame:  [mark]  = 9,000us\n             *                  [space] = 4,500us\n             * markAndSpace             ~ 13.5ms\n             */\n            return IR_INCOMPLETE;\n        } else {\n            return IR_INCOMPLETE;\n        }\n    }\n\n    export function handleIrEvent(irEvent: number) {\n        /* Refresh repeat timer */\n        if (irEvent === IR_DATAGRAM || irEvent === IR_REPEAT) {\n            irState.repeatTimeout = input.runningTime() + REPEAT_TIMEOUT_MS;\n        }\n\n        /* Processing when full 32 bits are received */\n        if (irEvent === IR_DATAGRAM) {\n            irState.hasNewDatagram = true;\n\n            if (irState.onIrDatagram) {\n                background.schedule(irState.onIrDatagram, background.Thread.UserCallback, background.Mode.Once, 0);\n            }\n\n            const newCommand = irState.commandSectionBits & 0xFF;\n\n            /* Process a new command */\n            if (newCommand !== irState.activeCommand) {\n\n                if (irState.activeCommand >= 0) {\n                    const releasedHandler = irState.onIrButtonReleased.find(h => h.irButton === irState.activeCommand || IrButton.Any === h.irButton);\n                    if (releasedHandler) {\n                        background.schedule(releasedHandler.onEvent, background.Thread.UserCallback, background.Mode.Once, 0);\n                    }\n                }\n\n                const pressedHandler = irState.onIrButtonPressed.find(h => h.irButton === newCommand || IrButton.Any === h.irButton);\n                if (pressedHandler) {\n                    background.schedule(pressedHandler.onEvent, background.Thread.UserCallback, background.Mode.Once, 0);\n                }\n\n                irState.activeCommand = newCommand;\n            }\n        }\n    }\n\n    export function enableIrMarkSpaceDetection(pin: DigitalPin) {\n        pins.setPull(pin, PinPullMode.PullNone);\n\n        let mark = 0;\n        let space = 0;\n\n        /**\n         * Indicates the duration of time when this pin is LOW\n         * \n         * That is, the time (us) is calculated from the time this pin starts LOW [Edge down]\n         * Until this pin level HIGH [Edge up]\n         * \n         * Then store in [mark] (burst)\n         */\n        pins.onPulsed(pin, PulseValue.Low, () => {\n            mark = pins.pulseDuration();\n        });\n\n        /**\n         * Indicates the duration of time when this pin is HIGH\n         * \n         * That is, the time (us) is calculated from the time this pin starts HIGH [Edge up]\n         * Until this pin level LOW [Edge down]\n         * \n         * Then store in [space]\n         */\n        pins.onPulsed(pin, PulseValue.High, () => {\n            space = pins.pulseDuration();\n\n            const status = decode(mark + space);\n\n            /**\n             * Process when one of the following status signals is received:\n             * [IR_REPEAT] or [IR_DATAGRAM]\n             */\n            if (status !== IR_INCOMPLETE) {\n                handleIrEvent(status);\n            }\n        });\n    }\n\n    export function notifyIrEvents() {\n        /* Skip to save CPU cylces */\n        if (irState.activeCommand === -1) {\n        } else {\n            const now = input.runningTime();\n\n            /* Repeat timed out */\n            if (now > irState.repeatTimeout) {\n\n                const handler = irState.onIrButtonReleased.find(h => h.irButton === irState.activeCommand || IrButton.Any === h.irButton);\n                if (handler) {\n                    background.schedule(handler.onEvent, background.Thread.UserCallback, background.Mode.Once, 0);\n                }\n\n                irState.bitsReceived = 0;\n                irState.activeCommand = -1;\n            }\n        }\n    }\n\n    export function connectIrReceiver(sig: PinKit) {\n        /* Port? */\n        let pin;\n        switch (sig) {\n            case PinKit.P0: pin = DigitalPin.P0; break;\n            case PinKit.P1: pin = DigitalPin.P1; break;\n            case PinKit.P2: pin = DigitalPin.P2; break;\n            case PinKit.P13: pin = DigitalPin.P13; break;\n            case PinKit.P14: pin = DigitalPin.P14; break;\n            case PinKit.P15: pin = DigitalPin.P15; break;\n        }\n\n        initIrState();\n        enableIrMarkSpaceDetection(pin);\n        background.schedule(notifyIrEvents, background.Thread.Priority, background.Mode.Repeat, REPEAT_TIMEOUT_MS);\n    }\n\n    export function ir_rec_to16BitHex(value: number): string {\n        let hex = \"\";\n\n        for (let pos = 0; pos < 4; pos++) {\n            let remainder = value % 16;\n            if (remainder < 10) {\n                hex = remainder.toString() + hex;\n            } else {\n                hex = String.fromCharCode(55 + remainder) + hex;\n            }\n            value = Math.idiv(value, 16);\n        }\n\n        return hex;\n    }\n\n    /* --------------------------------------------------------------------- */\n\n    /**\n     * Read received IR signal value, NEC standard\n     * @param chooseValue select the type of value IR you want to read\n     * @param sig signal pin (default P0)\n     */\n    //% block=\"M14 IR Remote \\\\| Read $chooseValue NEC from port $sig\"\n    //% chooseValue.defl=ValueIR.Command\n    //% sig.defl=PinKit.P0 sig.fieldEditor=\"gridpicker\" sig.fieldOptions.columns=3\n    //% inlineInputMode=inline\n    //% weight=2\n    //% group=\"Get Info Infrared (Data)\"\n    export function readValueIR(chooseValue: ValueIR, sig: PinKit): number {\n        /* Make sure to initialize IR at first use */\n        if (!_initOneTime) {\n            connectIrReceiver(sig);\n            _initOneTime = true;\n        }\n\n        /* Yield to support background processing when called in tight loops */\n        basic.pause(0);\n        initIrState();\n        if (irState.hasNewDatagram) {\n            irState.hasNewDatagram = false;\n            /* ------------------------------------------------------------- */\n            basic.pause(0);//! Yield\n            if (!irState) {\n                return IrButton.Any;\n            }\n            switch (chooseValue) {\n                case ValueIR.Command: return irState.commandSectionBits & 0xFF;\n                case ValueIR.Address: return irState.addressSectionBits & 0xFF;\n                case ValueIR.RawData: return irState.commandSectionBits * 65536 + irState.addressSectionBits;\n                default: return 0;\n            }\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Print all information about the received IR signal, NEC standard\n     * @param sig signal pin (default P0)\n     */\n    //% block=\"M14 IR Remote \\\\| Print IR NEC result short from $sig port\"\n    //% sig.defl=PinKit.P0 sig.fieldEditor=\"gridpicker\" sig.fieldOptions.columns=3\n    //% inlineInputMode=inline\n    //% weight=1\n    //% group=\"Get Info Infrared (Text)\"\n    export function printValueIR(sig: PinKit): string {\n        /* Make sure to initialize IR at first use */\n        if (!_initOneTime) {\n            connectIrReceiver(sig);\n            _initOneTime = true;\n        }\n\n        /* Yield to support background processing when called in tight loops */\n        basic.pause(0);\n        initIrState();\n        if (irState.hasNewDatagram) {\n            irState.hasNewDatagram = false;\n            /* ------------------------------------------------------------- */\n            basic.pause(0);//! Yield\n            initIrState();\n            let A = ir_rec_to16BitHex(irState.addressSectionBits);\n            let C = ir_rec_to16BitHex(irState.commandSectionBits);\n            return (\n                \"A: 0x\" + A.substr(2, 2) + \"\\n\" +\n                \"C: 0x\" + C.substr(2, 2) + \"\\n\" +\n                \"D: 0x\" + C + A\n            );\n        } else {\n            return \"NONE\";\n        }\n    }\n}\n","README.md":"\n> Open this page at [https://makerlabvn.github.io/makeredu_hardware/](https://makerlabvn.github.io/makeredu_hardware/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/makerlabvn/makeredu_hardware** and import\n\n## Edit this project ![Build status badge](https://github.com/makerlabvn/makeredu_hardware/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/makerlabvn/makeredu_hardware** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/makerlabvn/makeredu_hardware/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit \n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt-ds18b20.cpp":"#include \"pxt.h\"\n\nnamespace ds18b20\n{\n  MicroBitPin *pin = &uBit.io.P0;\n\n  /* ----------------------------------------------------------------------- */\n\n  void sleep_us(uint32_t us)\n  {\n    uint32_t lasttime, nowtime;\n    lasttime = system_timer_current_time_us();\n    nowtime = system_timer_current_time_us();\n    while ((nowtime - lasttime) < us)\n    {\n      nowtime = system_timer_current_time_us();\n    }\n  }\n\n  /* ----------------------------------------------------------------------- */\n\n  /* Write Time Slots\n  **\n  ** The bus master uses a Write 1 time slot to write a logic 1 to the DS18B20\n  ** And a Write 0 time slot to write a logic 0 to the DS18B20\n  **\n  ** All write time slots must be a minimum of 60¬µs in duration\n  ** With a minimum of a 1¬µs recovery time between individual write slots\n  **\n  ** To generate a Write 1 time slot, after pulling the 1-Wire bus low\n  ** The bus master must release the 1-Wire bus within 15¬µs\n  **\n  ** To generate a Write 0 time slot, after pulling the 1-Wire bus low\n  ** The bus master must continue to hold the bus low for the duration of the time slot (at least 60¬µs)\n  */\n  void ds18b20WiteByte(uint8_t data)\n  {\n    for (int i = 0; i < 8; i++)\n    {\n      if ((data >> i) & 0x01) // Write bit 1\n      {\n        pin->setDigitalValue(0);\n        sleep_us(2);          // Master pull LOW\n        pin->setDigitalValue(1);\n        sleep_us(60);         // Master release\n      }\n      else                    // Write bit 0\n      {\n        pin->setDigitalValue(0);\n        sleep_us(60);         // Master pull LOW\n        pin->setDigitalValue(1);\n        sleep_us(2);          // Master release\n      }\n    }\n  }\n\n  /* Read Time Slots\n  **\n  ** The DS18B20 can only transmit data to the master when the master issues read time slots\n  ** Therefore, the master must generate read time slots\n  **\n  ** All read time slots must be a minimum of 60¬µs in duration\n  ** With a minimum of a 1¬µs recovery time between slots\n  **\n  ** The master device pulling the 1-Wire bus low for a minimum of 1¬µs and then releasing the bus\n  ** The DS18B20 will begin transmitting a 1 or 0 on bus\n  **\n  ** The master must release the bus and then sample the bus state within 15¬µs from the start of the slot\n  ** The DS18B20 transmits a 1 by leaving the bus high and transmits a 0 by pulling the bus low\n  */\n  uint8_t ds18b20ReadBit()\n  {\n    uint8_t bit;\n\n    pin->setDigitalValue(0);\n    sleep_us(2);  // Master pull LOW\n    pin->setDigitalValue(1);\n    sleep_us(5);  // Master release\n\n    if (pin->getDigitalValue())\n      bit = 1;    // Read bit 1\n    else\n      bit = 0;    // Read bit 0\n    sleep_us(60);\n\n    return bit;\n  }\n\n  /* Read Scratchpad [BEh]\n  **\n  ** The data transfer starts with the least significant bit of byte 0\n  ** And continues through the scratchpad until the 9th byte (byte 8 ‚Äì CRC) is read\n  **\n  ** Byte 0 : TEMPERATURE LSB\n  ** Byte 1 : TEMPERATURE MSB\n  ** Byte 2 : TH REGISTER OR USER BYTE 1\n  ** Byte 3 : TL REGISTER OR USER BYTE 2\n  ** Byte 4 : CONFIGURATION REGISTER\n  ** Byte 5 : RESERVED\n  ** Byte 6 : RESERVED\n  ** Byte 7 : RESERVED\n  ** Byte 8 : CRC\n  */\n  uint8_t ds18b20ReadByte()\n  {\n    uint8_t bit;\n    uint8_t data = 0;\n\n    for (int i = 0; i < 8; i++)\n    {\n      bit = ds18b20ReadBit();\n      sleep_us(2);\n\n      data = data | (bit << i);\n    }\n    sleep_us(2);\n\n    return data;\n  }\n\n  /* ----------------------------------------------------------------------- */\n\n  /* Reset Pulses\n  **\n  ** All communication with the DS18B20 begins with an initialization sequence\n  ** That consists of a reset pulse from the master followed by a presence pulse from the DS18B20\n  **\n  ** During the initialization sequence\n  ** The bus master transmits (TX) the reset pulse by pulling the 1-Wire bus low for a minimum of 480¬µs\n  */\n  void ds18b20Rest()\n  {\n    pin->setDigitalValue(0);\n    sleep_us(750);  // MASTER Tx RESET PULSE\n    pin->setDigitalValue(1);\n    sleep_us(15);   // DS18B20 WAITS\n  }\n\n  /* Presence Pulses\n  **\n  ** The bus master then releases the bus and goes into receive mode (RX)\n  ** When the DS18B20 detects this rising edge, it waits 15¬µs to 60¬µs\n  ** And then transmits a presence pulse by pulling the 1-Wire bus low for 60¬µs to 240¬µs\n  */\n  bool ds18b20Check()\n  {\n    int state = 0;\n    while (pin->getDigitalValue())  // DS18B20 WAITS (if still have)\n    {\n      state++;\n      sleep_us(1);\n      if (state >= 80)\n        return false;\n    }\n\n    state = 0;\n    while (!pin->getDigitalValue()) // DS18B20 TX PRESENCE\n    {\n      state++;\n      sleep_us(1);\n      if (state >= 260)\n        return false;\n    }\n\n    sleep_us(180);\n    return true; \n  }\n\n  /* Transaction Sequence\n  **\n  ** The transaction sequence for accessing the DS18B20 is as follows:\n  ** Step 1. Initialization\n  ** Step 2. ROM Command\n  ** Step 3. DS18B20 Function Command\n  */\n  void ds18b20Start()\n  {\n    ds18b20Rest();          // Reset Pulses\n    ds18b20Check();         // Presence Pulses\n    sleep_us(2);\n    ds18b20WiteByte(0xCC);  // ROM Commands       : Skip Rom [CCh]\n    ds18b20WiteByte(0x44);  // Function Commands  : Convert T [44h]\n  }\n\n  /* ----------------------------------------------------------------------- */\n  /*                                   MAIN                                  */\n  /* ----------------------------------------------------------------------- */\n\n  /*\n  ** The 1-Wire bus must be switched to the strong pullup\n  ** Within 10¬µs (max) after a Convert T [44h] or Copy Scratchpad [48h] command is issued\n  **\n  ** The bus must be held high by the pullup for the duration of the conversion (tCONV) or data transfer (tWR = 10ms)\n  ** No other activity can take place on the 1-Wire bus while the pullup is enabled\n  */\n  float ds18b20GetTemperture()\n  {\n    uint8_t TH, TL;\n    uint16_t temp;\n\n    ds18b20Start();\n\n    /* The 1-Wire bus must be switched to the strong pullup within 10¬µs (max)\n    ** After a Convert T [44h] or Copy Scratchpad [48h] command is issued\n    ** And the bus must be held high by the pullup for the duration of the conversion (tCONV) or data transfer (tWR = 10ms)\n    ** No other activity can take place on the 1-Wire bus while the pullup is enabled\n    **\n    ** 12-bit resolution. tCONV max is 750ms\n    */\n    sleep_us(10000);        //! Temperature Conversion Time (tCONV)\n\n    /************************/\n    ds18b20Rest();          // Reset Pulses\n    ds18b20Check();         // Presence Pulses\n    sleep_us(2);\n    ds18b20WiteByte(0xCC);  // ROM Commands       : Skip Rom [CCh]\n    ds18b20WiteByte(0xBE);  // Function Commands  : Read Scratchpad [BEh]\n    /************************/\n    TL = ds18b20ReadByte();\n    TH = ds18b20ReadByte();\n    /************************/\n\n    //! Use for Debug\n    // uBit.serial.printf(\"TH: %d\\r\\n\", TH);\n    // uBit.serial.printf(\"TL: %d\\r\\n\", TL);\n\n    /*     |--- MS BYTE -----------------------|   |--- LS BYTE -----------------------|\n    ** Bit 15 - 14 - 13 - 12 - 11 - 10 - 09 - 08 - 07 - 06 - 05 - 04 - 03 - 02 - 01 - 00\n    **      S    S    S    S    S   2^+6 2^+5 2^+4 2^+3 2^+2 2^+1 2^+0 2^-1 2^-2 2^-3 2^-4\n    **\n    ** Negative Numbers S = 1\n    ** Positive Numbers S = 0\n    */\n    if ((TH & 0xF8) == 0xF8 || (TH & 0xF8) == 0x00)\n    {\n      temp = (TH * 256) + TL;\n\n      if ((temp & 0xF800) == 0xF800)  // Sign = 1 (Negative numbers)\n      {\n        temp = (~temp) + 1;\n        return temp * -0.0625;\n      }\n      else                            // Sign = 0 (Positive numbers)\n        return temp * 0.0625;\n    }\n    else\n    {\n      return 999;\n    }\n  }\n\n  /* ----------------------------------------------------------------------- */\n  /*                                  BLOCK                                  */\n  /* ----------------------------------------------------------------------- */\n\n  //%\n  float temperature(int p)\n  {\n    switch (p)\n    {\n    case 0:\n      pin = &uBit.io.P0;\n      break;\n    case 1:\n      pin = &uBit.io.P1;\n      break;\n    case 2:\n      pin = &uBit.io.P2;\n      break;\n    case 3:\n      pin = &uBit.io.P13;\n      break;\n    case 4:\n      pin = &uBit.io.P14;\n      break;\n    case 5:\n      pin = &uBit.io.P15;\n      break;\n    default:\n      pin = &uBit.io.P0;\n    }\n    return ds18b20GetTemperture();\n  }\n}\n","pxt-ds3231.cpp":"#include \"pxt.h\"\n\nnamespace ds3231\n{\n  //%\n  String get_DATE()\n  {\n    return PSTR(__DATE__);\n  }\n\n  //%\n  String get_TIME()\n  {\n    return PSTR(__TIME__);\n  }\n}","shims.d.ts":"// Auto-generated. Do not edit.\ndeclare namespace ds18b20 {\n\n    /************************/\n    //% shim=ds18b20::temperature\n    function temperature(p: int32): number;\n}\n\n// Auto-generated. Do not edit. Really.\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}}